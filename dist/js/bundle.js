/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/script.js":
/*!**************************!*\
  !*** ./src/js/script.js ***!
  \**************************/
/***/ (() => {

eval("function _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n/*\r\n1. Створити клас Людина.\r\n\r\nВластивості:\r\nімʼя;\r\nстать.\r\nМетоди:\r\nконструктор, який приймає два параметри: імʼя та стать.\r\n\r\n2. Створити клас Квартира.\r\nВластивості:\r\nконструктор не потрібен;\r\nмасив жителів, який при створенні пустий.\r\nМетоди:\r\nдодати жителя - метод повинен приймати екземпляр класу Людина, \r\nта додавати до масиву жителів.\r\n\r\n\r\n3. Створити клас Будинок.\r\n\r\nВластивості:\r\nмасив квартир, який при створенні пустий;\r\nмаксимальна кількість квартир.\r\nМетоди:\r\nконструктор, який приймає один параметр:\r\nмаксимальну кількість квартир;\r\nдодати квартиру - метод повинен приймати екземпляр\r\nкласу Квартира, перевіряти, \r\nчи не буде кількість перевищувати максимальну кількість \r\nквартир, і якщо це так, додати квартиру, \r\nв іншому випадку виводить у консоль відповідне повідомлення.\r\nВ якості демонстраціїї створити:\r\n\r\nдекілька екземплярів класу Людина;\r\nдекілька екземплярів класу Квартира;\r\nдодадити екземпляри класу Людина до екземплярів класу Квартира;\r\nекземпляр класу Будинок;\r\nдодадити екземпляри класу Квартира до екземплярів класу Будинок.\r\n\r\n/*\r\n+\r\nmaxPeopleInFlat такого в умові нема - не треба додумувати :)\r\n\r\nmaxFlats = 3; - те саме - не треба додумувати. Ця властивість \r\nзадається в конструкторі - тому ми можемо бути впевненими, що вона \r\nствориться. \r\n\r\nreturn null; як і return this - використовується досить рідко, \r\nвідношення до методів класу має бути як що звичайної фуцкнії - \r\nі вертати вона має щось що притаманно їй - не обов\"язково this або \r\nвзагалі\r\nбудь-що :) В твому випадку якщо ми \r\nвиклечемо зайвий раз house1.addFlat().addPerson(person5) - буде помилка, \r\nбо addFlat() поверне null. Ну і тут помилка в тому, \r\nщо addFlat() має приймати квартиру як аргумент, а не створювати її\r\n*/\nvar Person = /*#__PURE__*/_createClass(function Person(name, gender) {\n  _classCallCheck(this, Person);\n  this.name = name;\n  this.gender = gender;\n});\nvar Flat = /*#__PURE__*/function () {\n  function Flat() {\n    _classCallCheck(this, Flat);\n    _defineProperty(this, \"peopleInFlat\", []);\n  }\n  _createClass(Flat, [{\n    key: \"addPerson\",\n    value: function addPerson(person) {\n      this.peopleInFlat.push(person);\n      return this.peopleInFlat;\n    }\n  }]);\n  return Flat;\n}();\nvar House = /*#__PURE__*/function () {\n  function House(maxFlats) {\n    _classCallCheck(this, House);\n    _defineProperty(this, \"flats\", []);\n    _defineProperty(this, \"maxFlats\", void 0);\n    this.maxFlats = maxFlats;\n  }\n  _createClass(House, [{\n    key: \"addFlat\",\n    value: function addFlat() {\n      if (this.flats.length < this.maxFlats) {\n        var newFlat = new Flat(); // Создаем новый экземпляр класса Flat\n        this.flats.push(newFlat);\n        return newFlat;\n      } else {\n        throw new Error(\"The house is full, please make a new house\");\n      }\n    }\n  }]);\n  return House;\n}();\nvar person1 = new Person(\"Heinrich\", \"male\");\nvar person2 = new Person(\"Mikki\", \"female\");\nvar person3 = new Person(\"Billy\", \"male\");\nvar person4 = new Person(\"Lily\", \"female\");\nvar person5 = new Person(\"Bartek\", \"male\");\nvar person6 = new Person(\"Iwona\", \"female\");\nvar person7 = new Person(\"Iwan\", \"male\");\nvar person8 = new Person(\"Maria\", \"female\");\nvar house1 = new House(3);\ntry {\n  // Расселяем по квартирам\n  var flat1 = house1.addFlat();\n  flat1.addPerson(person1);\n  flat1.addPerson(person2);\n  var flat2 = house1.addFlat();\n  flat2.addPerson(person3);\n  flat2.addPerson(person4);\n  var flat3 = house1.addFlat();\n  flat3.addPerson(person5);\n  flat3.addPerson(person6);\n  /* При создании 4-й квартиры выдаст ошибку*/\n\n  // let flat4 = house1.addFlat();\n  // flat4.addPerson(person7);\n  // flat4.addPerson(person8);\n\n  console.log(house1.flats);\n} catch (error) {\n  console.error(error.message);\n}\n;\n\n//# sourceURL=webpack:///./src/js/script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/script.js"]();
/******/ 	
/******/ })()
;